# Bubble sort
# best: O(n), worst: O(n^2), average: O(n^2), worst space: O(1) auxillary

# Selection Sort
# best: O(n), worst: O(n^2), average: O(n^2), worst space: O(1) auxillary

# Insertion Sort
# best: O(n^2), worst: O(n^2), average: O(n^2), worst space: O(1) auxillary, O(n^2) total

# Shell Sort
# best: O(n), worst: O(n.log^2(n)), average: depends on gap sequence, worst space: O(n)

# Merge Sort
# best: theta(n.logn), worst: theta(n.logn), average: theta(n.logn), worst space: theta(n) auxillary

# Heap Sort -- implemented in file binary_heaps.py
# best: theta(n.logn), worst: theta(n.logn), average: theta(n.logn), worst space: theta(1) auxillary, theta(n) total

# Quick Sort
# best: O(n.logn), worst: O(n^2), average: O(n.logn), worst space: O(1)

# Tree Sort
# worst: O(n^2), average: O(n.logn), worst space: O(n) auxillary

# Counting Sort

# Topological Sort -- implemented in Graphs.py

# given array of n numbers containing repetition of some numbers. check whether there are repeated elements or not.
# time O(n^2), space O(1) -- brute force technique

# given array of n numbers containing repetition of some numbers. check whether there are repeated elements or not.
# time O(n.logn), space O(1) -- sorting technique

# given array where each element represents a vote in election. Each vote integer represents ID of chosen candidate.
# Determine who wins the election , time O(n^2), space O(1)

# given array where each element represents a vote in election. Each vote integer represents ID of chosen candidate.
# Determine who wins the election , time O(n.logn), space O(1) heap sort

# given array where each element represents a vote in election. Each vote integer represents ID of chosen candidate.
# Determine who wins the election , time O(n) n= no. of votes in array, space O(k) k=no.of candidates participated
# counting sort

# given an array of n elements, each integer in range [1, n^2]. sort array in O(n) time

# given an array of n elements, each integer in range [1, n^3]. sort array in O(n) time

# given arrays A and B, a number K, determine whether there exists a∈A, b∈B such that a+b = K, time O{n.logn)

# given arrays A and B, a number K, determine whether there exists a∈A, b∈B, c∈C such that a+b+c = K, time O{n.logn)

# sort an array of 0's, 1's and 2's. put all o first, then 1 and all 2 in last. (counting sort)

# sort an array of 0's, 1's and 2's. put all o first, then 1 and all 2 in last. (quick sort)

# better sorting method for linked list - Merge sort

# merge two sorted arrays. first array of size m+n with m elements, second array with n elements




