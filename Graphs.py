
# graph declaration as adjacency matrix

# graph declaration as adjacency list

# create an undirected graph using adjacency matrix

# create an undirected graph using adjacency list

# create a directed acyclic graph

# graph traversal - Depth First Search

# graph traversal - Breadth First Search

# topological sort in directed acyclic graph

# find shortest path in unweighted directed graph (modified BFS)

# find shortest path in weighted directed graph (Dijkstra algorithm)

# find shortest path in weighted directed graph with negative edges (Bellman-Ford algorithm)

# find shortes path in weighted acyclic graph

# find minimum spanning tree in undirected weighted graph - Prim's algorithm
# for unweighted graphs we consider all weights are equal

# find minimum spanning tree in undirected weighted graph - Kruskal's algorithm

# Given a graph as adjacency matrix, check whether graph has simple path from source to destination

# Given a graph as adjacency matrix, count all simple paths from source to destination in graph

# find shortest path between every pair of vertices in graph. Assume graph doesn't have negative edges
# can be solved using n applications of Dijkstra

# find shortest path between every pair of vertices in graph. Assume graph has negative edges
# Floyd-Warshall algorithm

# find the cut-vertex in an undirected graph (DFS application)
# Cut-Vertex is a vertex if removed then graph splits into two disconnected components

# find cut-edge in an undirected graph (DFS application)
# cut-edge is an edge if removed then graph splits into two disconnected components

# find a cycle in undirected graph that visits every vertex (Hamiltonian cycle problem)

# find strongly connected components (DFS application)

# count number of connected components of graph given as adjacent matrix (using DFS)

# count number of connected components of graph given as adjacent matrix (using BFS)

# detect a cycle in undirected graph in constant time, not necessarily a minimum spanning tree

# detect cycle in directed graph

# find depth of directed acyclic graph
# for undirected graph, use simple unweighted shortest path algorithm and return highest no. among all distances

# determine whether a directed graph has a unique topological ordering

# find lowest common ancestor of 2 vertices in directed acyclic graph "DAG"

# Given DAG, find shortest ancestral path between two vertices

# check two given graphs are isomorphic or not

# given directed graph, return the reverse graph. each edge from v to w is replaced by edge from w to v


